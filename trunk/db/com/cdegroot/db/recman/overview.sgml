<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<article>
  <sect1>
    <title>Record Management Overview</title>
    <para>This is a short overview that should serve as a guide to the
code itself, which has extensive doc comments with all the
details.</para>
    <sect2>
      <title>Files, Blocks and Pages</title>
      <para>The lowest level consists of files and blocks, defined in
the <structname>RecordFile</structname> and
<structname>BlockIo</structname> classes. A file consists simply of a
run of physical blocks, numbered starting at
0. <structname>RecordFile</structname> reads and caches these blocks,
and keeps a dirty list so we know what to write when a transaction is
committed.</para>
      <para><structname>PageManager</structname> adds a bit of
structure to the blocks by arranging them in linked lists. Block 0
becomes special (the fileheader), and every block starts with a couple
of reserved bytes that point to the next and previous elements in the
list the block belongs to (plus a magic code making sure that the
structural information is correct). The <structname>Magic</structname> class
has some linked list types, but basically they fall apart in two
categories: the free list containing blocks that can be reused, and a
number of specialized lists. The file header (as defined in
<structname>FileHeader</structname>) contains head and tail
pointers for all the lists (this limits the number of lists to the
amount of pointers that fit in the file header).</para>
      <para>This level also shows how data inside blocks is
interpreted (this is the whole difference between blocks and pages:
pages are blocks that are
interpreted). <structname>BlockIo</structname> objects can have a
<structname>BlockView</structname> that is responsible for the
interpretation attached to them. The simplest instance of this type is
the <structname>PageHeader</structname>, which interprets the first
bytes of a block (making it a page): magic code, previous block, and
next block.</para>
      <para>One design decision has been to do the interpretation
on-the-fly: reading the "previous block" pointer for a page means that
all 8 bytes are read from the corresponding location in the block's
raw bytes, and shifted and or'ed together. Performance-wise, this does
not have such a large impact as one would think, and it keeps the code
flexible and extensible.</para>
    </sect2>
    <sect2>
      <title>Data Storage, Physical RowIds</title>
      <para>All data stored in the system is variable length and may
be extended or truncated at will during updates. Data is contained in
<structname>DataPage</structname> pages, which are pages with a little
bit of metadata (basically, a pointer to the first data item on the
page). The location of a data item is called a
<structname>PhysicalRowId</structname>, which is a simple
concatenation of the page where the data starts with the offset within
the page where the data starts. A lot of the code in
<structname>PhysicalRowIdManager</structname> deals with finding slots
of enough space, possibly running over multiple pages, concatenating
fragments of data together, etcetera. When physical rowids are
released, they land on <structname>FreePhysicalRowIdPage</structname>
pages, together with their maximum size (which may be larger than
their latest real size). These pages are scanned first in order to
satisfy allocation requests.</para>
    </sect2>
    <sect2>
      <title>Logical RowIds</title>
      <para>During update, a data item may be moved and therefore get
a different physical rowid. This would be cumbersome to the user and
therefore the system contains an indirection layer. A
<structname>LogicalRowIdManager</structname> works together with a
<structname>FreeLogicalRowIdManager</structname> to map logical rowids
to physical rowids. Both rowid types are the same (a block, offset
tuple), but the indirection makes sure that the user does not need to
deal with changing identifiers when they update data. Pages containing
the mappings are described by <structname>TranslactionPage</structname></para>
    </sect2>
    <sect2>
      <title>Transactions</title>
      <para>There is a simple, low-level transaction mechanism that
makes sure that changes are atomic, consistent and durable. As the
interface is single-user, independence between concurrent transactions
is not an issue.</para>
      <para>Changed pages are flushed to a logfile when a transaction
is committed, and the logfile is synchronized to disk. After a number
of transactions or during recovery, the logfile is read and used to
update the data file. <structname>BlockIo</structname> has everything
that is necessary for the transaction log (the block number and the
data), so it is simply serialized to the log.</para>
    </sect2>
  </sect1>
</article>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-namecase-general:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-parent-document:nil
sgml-default-dtd-file:"docbook31.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
